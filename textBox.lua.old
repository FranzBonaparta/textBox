local Object = require("libs.classic")
local TextBox = Object:extend()

local font = love.graphics.newFont("NotoSans-Regular.ttf", 14)

function TextBox:new(x, y, w, lh)
    self.x = x
    self.y = y
    self.w = w
    self.lineHeight = lh

    self.lines = { "" }
    self.focused = false

    self.cursor = { col = 1, line = 1 }
    self.cursorVisible = true
    self.cursorTimer = 0

    self.padding = 4
    self.canvas = love.graphics.newCanvas(self.w, self.lineHeight)
    self:setCanvas()
end

function TextBox:setCanvas()
    local canvasHeight = self.padding * 2 + self.lineHeight * #self.lines
    self.canvas = love.graphics.newCanvas(self.w, canvasHeight)
    love.graphics.setCanvas(self.canvas)
    love.graphics.clear()
    love.graphics.setFont(font)

    -- background
    love.graphics.setColor(1, 1, 1)

    love.graphics.rectangle("fill", 0, 0, self.w, canvasHeight)
    --print(#self.lines, self.lineHeight * #self.lines)
    -- border

    if #self.lines>=1 and #self.lines[1] > 0 then
        love.graphics.setColor(0, 0, 0)
    else
        love.graphics.setColor(0, 0, 0, 0.4)
    end

    --love.graphics.rectangle("line", 0, 0, self.w, self.lineHeight*#self.lines)

    -- text
    if #self.lines == 1 and self.lines[1] == "" then
        love.graphics.print("Write here", self.padding, self.padding)
    else
        for i, line in ipairs(self.lines) do
            love.graphics.print(line, self.padding, self.padding + ((i - 1) * self.lineHeight))
        end
    end
    love.graphics.setCanvas()
end

function TextBox:draw()
    love.graphics.draw(self.canvas, self.x, self.y)
    -- cursor to the end
    if self.focused and self.cursorVisible then
        love.graphics.setColor(0, 0, 0)
        local before = self.lines[self.cursor.line]:sub(1, self.cursor.col - 1) or ""
        local textWidth = font:getWidth(before)
        -- cursor height is depending of the font's height
        local height = self.lineHeight
        --calculate the position of the cursor
        local cx = self.x + self.padding + textWidth
        local cy = self.y + ((self.cursor.line - 1) * self.lineHeight) + self.padding
        --drawing the cursor
        love.graphics.line(
            cx, cy,
            cx, (cy + height - self.padding)
        )
    end
end

function TextBox:getCharIndexFromPixel(mx, my)
    local y = math.max(math.floor((my - self.y - self.padding) / self.lineHeight) + 1, 1)
    local line = self.lines[y]
    local x = mx - (self.x + self.padding)
    if x < 0 then return 1, y end

    if not line then
        local lastLine = self.lines[#self.lines]
        return #lastLine + 1, #self.lines
    end

    local acc = 0
    for i = 1, #line do
        local ch = line:sub(i, i)
        local w = font:getWidth(ch)
        if acc + w >= x then
            return i, y
        end
        acc = acc + w
    end

    -- clic after the end
    return #line + 1, y
end

function TextBox:resetLocation(index, remain, isbackSpace)
    if not isbackSpace then
        return
    end
    --reset cursor's location
    if self.cursor.line == index then
        if self.cursor.col > #remain then
            self.cursor.line = self.cursor.line + 1
            self.cursor.col = self.cursor.col - #remain
        end
    end
    --cascade
    self:adjustLines(index + 1)
end

function TextBox:addToLines(t)
    if not self.focused then return end

    local text = self.lines[self.cursor.line]
    local before = text:sub(1, self.cursor.col - 1)
    local after = text:sub(self.cursor.col)
    --reconstruct current line
    local newLine = before .. t .. after
    --update the buffer
    self.lines[self.cursor.line] = newLine
    --clean wrap
    local moved=self:adjustLines(self.cursor.line,false)
    --move the cursor
    if moved==0 then
     self.cursor.col = self.cursor.col + 1 
    else
        self.cursor.col=moved+1
        self.cursor.line=self.cursor.line+1
    end
    self:setCanvas()
end

function TextBox:adjustLinesForSpaceBreak(spaceIndex,index)
--convert reverse index to normal
        spaceIndex = #self.lines[index] - spaceIndex + 1
        local moved = self.lines[index]:sub(spaceIndex + 1)
        local remain = self.lines[index]:sub(1, spaceIndex)
        --apply correctly
        self.lines[index] = remain
        --next line
        self.lines[index + 1] = moved .. (self.lines[index + 1] or "")
        return remain, moved
end

function TextBox:adjustLinesForHardWrap(index)
     --if no space we cut the word
        local cutchar = self.lines[index]:sub(#self.lines[index])
        local remain = self.lines[index]:sub(1, #self.lines[index] - 1)
        local length = font:getWidth(remain)
        while length >= self.w do
            cutchar = remain:sub(#remain) .. cutchar
            remain = remain:sub(1, #remain - 1)
            length = font:getWidth(remain)
        end
        self.lines[index] = remain
        self.lines[index + 1] = cutchar .. (self.lines[index + 1] or "")
        return remain, cutchar
    end
function TextBox:adjustLines(index, isBackSpace)
    --isbackSpace determine if the cursor need to move
    if isBackSpace == nil then isBackSpace = true end
    local length = font:getWidth(self.lines[index]or self.w)
    local moved=0
    if length < self.w then
        return 0--no wrap needed
    end
    --find the last space
    local reverse = self.lines[index]:reverse()
    local spaceIndex = reverse:find("%s")
    if spaceIndex then
        local _, movedText=self:adjustLinesForSpaceBreak(spaceIndex,index)
        --reset cursor's location
        moved=#movedText
        --self:resetLocation(index, remain, isBackSpace)
    else
        local _, cutChar=self:adjustLinesForHardWrap(index)
        --reset cursor's location
        moved=#cutChar
        --self:resetLocation(index, remain, isBackSpace)
    end
    return moved
end

function TextBox:deleteCharUnderCursor(lineIndex,isBackSpace)
        if isBackSpace == nil then isBackSpace = true end
local function deleteNearestChar()
    local actualLine=self.lines[lineIndex]
    self.lines[lineIndex]=actualLine:sub(1,math.max(0,self.cursor.col-1))..actualLine:sub(self.cursor.col+1) 
end
    local nextLine = self.lines[lineIndex + 1]
    local char = ""
    local lastLine = ""
    --if ther is no line after the focused line
    if not nextLine then
        if #self.lines[self.cursor.line] >= self.cursor.col then
            deleteNearestChar()
           --self:adjustLines(lineIndex, isBackSpace)
        end
        --return
    end

    for index = #self.lines, lineIndex + 1, -1 do
        lastLine = self.lines[index]
        char = lastLine:sub(1, 1)
        self.lines[index] = lastLine:sub(2, #lastLine)
        self.lines[index - 1] = (self.lines[index - 1]or "") .. char
    end
    if not isBackSpace then
       deleteNearestChar()
       self:adjustLines(lineIndex, false)
    end
    
    --erase last line if it's empty
    if #self.lines[#self.lines] == 0 and #self.lines>1 then
            table.remove(self.lines, #self.lines)        
    end
    self:adjustLines(lineIndex, isBackSpace)
end

function TextBox:mousepressed(mx, my, button)
    if button ~= 1 then return end

    self.focused =
        mx >= self.x and mx <= self.x + self.w and
        my >= self.y and my <= self.y + (self.lineHeight * #self.lines)
    if self.focused then
        local x, y = self:getCharIndexFromPixel(mx, my)
        self.cursor.col = x
        self.cursor.line = y
        self:setCanvas()
    else
        return
    end
end

function TextBox:update(dt)
    if self.focused then
        local keys={"left","right","up","down","delete","backspace"}
        self.cursorTimer = self.cursorTimer + dt
        if self.cursorTimer >= 0.5 then
--[[            for _, key in ipairs(keys) do
                if love.keyboard.isDown(key) then
                   self:keypressed(key) 
                end
            end]]
            self.cursorTimer = 0
            self.cursorVisible = not self.cursorVisible
        end
    else
        -- If there is no focus, the cursor is displayed as fixed or not at all.
        self.cursorVisible = false
        self.cursorTimer = 0
    end
end

function TextBox:keypressed(key)
    if not self.focused then return end
    local currentLine = self.lines[self.cursor.line]
    if key == "delete" then
        --local col = self.cursor.col
        self:deleteCharUnderCursor(self.cursor.line,false)
        --self.cursor.col = col
        self:setCanvas()
        return
    end
    if key == "backspace" then
        
        if self.cursor.line == 1 and self.cursor.col == 1 then
            return
        elseif self.cursor.line > 1 and self.cursor.col == 1 then
            local current = table.remove(self.lines, self.cursor.line)
            current=current:sub(self.cursor.line-1)
            self.cursor.line = self.cursor.line - 1
            self.cursor.col = #self.lines[self.cursor.line] 
            self.lines[self.cursor.line] = self.lines[self.cursor.line] .. current
        self:deleteCharUnderCursor(self.cursor.line-1)
        elseif self.cursor.col > 1 then
            -- deletes the character just before the cursor
            local before                 = currentLine:sub(1, self.cursor.col - 2)
            local after                  = currentLine:sub(self.cursor.col)

            self.lines[self.cursor.line] = before .. after
                self.cursor.col = self.cursor.col - 1
        end
        print(self.cursor.col)
        self:setCanvas()
        return
    end
    if key == "left" then
        self.cursor.col = math.max(1, self.cursor.col - 1)
        return
    end

    if key == "right" then
        self.cursor.col = math.min(#currentLine + 1, self.cursor.col + 1)
        return
    end
    if key == "up" then
        if self.lines[self.cursor.line - 1] then
            self.cursor.line = self.cursor.line - 1
            currentLine = self.lines[self.cursor.line]
            self.cursor.col = #currentLine >= self.cursor.col and self.cursor.col or #currentLine + 1
            return
        end
    end
    if key == "down" then
        if self.lines[self.cursor.line + 1] then
            self.cursor.line = self.cursor.line + 1
            currentLine = self.lines[self.cursor.line]
            self.cursor.col = #currentLine >= self.cursor.col and self.cursor.col or #currentLine + 1
            return
        end
    end
    if key == "return" or key == "kpenter" then
        local line = self.lines[self.cursor.line]
        local before = line:sub(1, self.cursor.col - 1)
        local after = line:sub(self.cursor.col)
        --look if next line exist
        self.lines[self.cursor.line + 1] =
            self.lines[self.cursor.line + 1] and after .. self.lines[self.cursor.line + 1]
            or after
        self:adjustLines(self.cursor.line + 1)
        self.lines[self.cursor.line] = before
        self.cursor.line = self.cursor.line + 1
        self.cursor.col = 1
        self:setCanvas()
        return
    end
end

return TextBox
